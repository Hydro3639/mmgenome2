#' @title Extract all scaffolds within a selection polygon
#' 
#' @description Finds all scaffolds that fall into a \code{selection} polygon highlighted in a plot generated by \code{\link{mmplot}}. 
#'
#' @param mm (\emph{required}) A dataframe loaded with \code{\link{mmload}}.
#' @param selection (\emph{required}) A 2-column dataframe with the x and y coordinates of a selection of points in an \code{\link{mmplot}}. The column names of the provided dataframe must match column names in \code{mm}. 
#' @param min_length Filter all scaffolds with a length at or below this value before the extraction. (\emph{Default: } \code{0})
#' @param inverse (\emph{Logical}) If \code{TRUE}, then the scaffolds within the \code{selection} are instead removed. (\emph{Default: } \code{FALSE})
#'
#' @export
#' 
#' @return A dataframe (tibble) compatible with other mmgenome2 functions.
#' 
#' @import sp
#' @import dplyr
#' @import tibble
#' 
#' @examples 
#' library(mmgenome2)
#' data(mmgenome2)
#' mmgenome2
#' selection <- data.frame(cov_C14.01.09 = c(24.852, 32.545, 53.062, 38.52),
#'                         cov_C13.12.03 = c(7.676, 5.165, 6.386, 10.933))
#' mmgenome2_extraction <- mmextract(mmgenome2, 
#'                                   min_length = 3000,
#'                                   selection = selection,
#'                                   inverse = FALSE)
#' mmgenome2_extraction
#' 
#' @author Kasper Skytte Andersen \email{ksa@@bio.aau.dk}
#' @author Soren M. Karst \email{smk@@bio.aau.dk}
#' @author Mads Albertsen \email{MadsAlbertsen85@@gmail.com}
mmextract <-  function(mm, 
                       selection,
                       min_length = 0,
                       inverse = FALSE) {
  if(!any(colnames(selection) %in% colnames(mm)))
    stop("Could not find any variable names in mm matching those in the selection.")
  
  #filter based on minimum length
  mm <- dplyr::filter(mm, length >= min_length)
  
  #return scaffolds only in the selection polygon
  in_polygon <- sp::point.in.polygon(point.x = mm[[colnames(selection)[1]]],
                                     point.y = mm[[colnames(selection)[2]]],
                                     pol.x = selection[[1]],
                                     pol.y = selection[[2]],
                                     mode.checked = TRUE)
  ifelse(isTRUE(inverse), 
         mm <- dplyr::filter(mm, in_polygon == 0), 
         mm <- dplyr::filter(mm, in_polygon > 0))
  return(tibble::as_tibble(mm))
}